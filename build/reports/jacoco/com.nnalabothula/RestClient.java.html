<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RestClient.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">secureRestClient</a> &gt; <a href="index.source.html" class="el_package">com.nnalabothula</a> &gt; <span class="el_source">RestClient.java</span></div><h1>RestClient.java</h1><pre class="source lang-java linenums">package com.nnalabothula;

import com.google.common.io.Resources;
import org.glassfish.jersey.SslConfigurator;
import org.glassfish.jersey.media.multipart.MultiPartFeature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedHashMap;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;
import javax.ws.rs.ext.ReaderInterceptor;
import javax.ws.rs.ext.ReaderInterceptorContext;
import javax.ws.rs.ext.WriterInterceptor;
import javax.ws.rs.ext.WriterInterceptorContext;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;
import java.security.Key;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.List;
import java.util.Map;
import java.util.zip.GZIPInputStream;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.junit.Assert.assertEquals;

@SuppressWarnings({&quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.ModifiedCyclomaticComplexity&quot;, &quot;PMD.StdCyclomaticComplexity&quot;})
public class RestClient {
<span class="fc" id="L50">  private static final Logger LOGGER = LoggerFactory.getLogger(RestClient.class);</span>

  private final Client client;
<span class="fc" id="L53">  private final MultivaluedMap&lt;String, Object&gt; multivaluedMap = new MultivaluedHashMap&lt;&gt;();</span>

  private Response response;

<span class="fc" id="L57">  public RestClient() {</span>
<span class="fc" id="L58">    client = createClientBuilder().build();</span>
<span class="fc" id="L59">  }</span>

<span class="fc" id="L61">  public RestClient(String keyStore, String keyStorePasswd, String keyStoreAlias, String tlsVersion) {</span>
<span class="fc" id="L62">    client = createSSLClient(keyStore, keyStorePasswd, keyStoreAlias, tlsVersion);</span>
<span class="fc" id="L63">  }</span>

  public MultivaluedMap&lt;String, Object&gt; getHeaders() {
<span class="fc" id="L66">    return multivaluedMap;</span>
  }

  public Response sendPostRequest(Object object, URI uri, MediaType mediaType) {
<span class="fc" id="L70">    response = client.target(uri).request().headers(multivaluedMap)</span>
<span class="fc" id="L71">        .post(Entity.entity(object, mediaType));</span>
<span class="fc" id="L72">    response.bufferEntity();</span>
<span class="fc" id="L73">    return response;</span>
  }

  public Response sendGetRequestWithEncoding(URI uri, MediaType mediaType, final String... encodings) {
<span class="fc" id="L77">    response = client.target(uri).request(mediaType).headers(multivaluedMap)</span>
<span class="fc" id="L78">        .acceptEncoding(&quot;deflate&quot;, &quot;gzip&quot;).get();</span>
<span class="fc" id="L79">    response.bufferEntity();</span>
<span class="fc" id="L80">    return response;</span>
  }

  public Response sendGetRequest(URI uri, MediaType mediaType) {
<span class="fc" id="L84">    response = client.target(uri).request(mediaType).headers(multivaluedMap).get();</span>
<span class="fc" id="L85">    response.bufferEntity();</span>
<span class="fc" id="L86">    return response;</span>
  }

  public Response sendPutRequest(Object object, URI uri, MediaType mediaType) {
<span class="fc" id="L90">    response = client.target(uri).request().headers(multivaluedMap)</span>
<span class="fc" id="L91">        .put(Entity.entity(object, mediaType));</span>
<span class="fc" id="L92">    response.bufferEntity();</span>
<span class="fc" id="L93">    return response;</span>
  }

  public Response sendDeleteRequest(URI uri) {
<span class="fc" id="L97">    response = client.target(uri).request().headers(multivaluedMap).delete();</span>
<span class="fc" id="L98">    response.bufferEntity();</span>
<span class="fc" id="L99">    return response;</span>
  }

  public void updateClientProperty(String property, boolean enabled) {
<span class="nc" id="L103">    client.property(property, enabled);</span>
<span class="nc" id="L104">  }</span>

  @SuppressWarnings(&quot;PMD.CyclomaticComplexity&quot;)
  private Client createSSLClient(String keyStoreFile, String keyStorePasswd, String httpsAlias, String tlsVersion) {
    try {
<span class="fc" id="L109">      URL keyStoreFileURL = Resources.getResource(keyStoreFile);</span>
<span class="fc" id="L110">      SslConfigurator sslConfig = SslConfigurator.newInstance().keyStoreFile(keyStoreFileURL.getFile())</span>
<span class="fc" id="L111">          .keyPassword(keyStorePasswd);</span>

<span class="fc" id="L113">      TrustManager[] trustAllCerts = new TrustManager[] {</span>
<span class="fc" id="L114">          new X509TrustManager() {</span>
        public X509Certificate[] getAcceptedIssuers() {
<span class="fc" id="L116">          return new X509Certificate[0];</span>
        }

        public void checkClientTrusted(X509Certificate[] certs, String authType) {
          //Empty
<span class="nc" id="L121">        }</span>

        public void checkServerTrusted(X509Certificate[] certs, String authType) {
          //Empty
<span class="fc" id="L125">        }</span>
      }
      };

      KeyManagerFactory keyManagerFactory;
      KeyStore keyStore, jks;

<span class="fc" id="L132">      keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span>
<span class="pc" id="L133">      try (InputStream fin = keyStoreFileURL.openStream();) {</span>
<span class="fc" id="L134">        keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span>
<span class="fc" id="L135">        jks = KeyStore.getInstance(KeyStore.getDefaultType());</span>
<span class="fc" id="L136">        keyStore.load(fin, keyStorePasswd.toCharArray());</span>
<span class="fc" id="L137">        jks.load(null);</span>

<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (keyStore.containsAlias(httpsAlias)) {</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">          if (keyStore.isKeyEntry(httpsAlias)) {</span>
<span class="fc" id="L141">            Certificate[] certChain = keyStore.getCertificateChain(httpsAlias);</span>
<span class="fc" id="L142">            Key key = keyStore.getKey(httpsAlias, keyStorePasswd.toCharArray());</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            for (Certificate cert : certChain) {</span>
<span class="fc" id="L144">              jks.setCertificateEntry(httpsAlias, cert);</span>
<span class="fc" id="L145">              jks.setKeyEntry(httpsAlias, key, keyStorePasswd.toCharArray(), certChain);</span>
            }
<span class="pc bnc" id="L147" title="All 2 branches missed.">          } else if (keyStore.isCertificateEntry(httpsAlias)) {</span>
<span class="nc" id="L148">            Certificate[] certChain = keyStore.getCertificateChain(httpsAlias);</span>
<span class="nc" id="L149">            Key key = keyStore.getKey(httpsAlias, keyStorePasswd.toCharArray());</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            for (Certificate cert : certChain) {</span>
<span class="nc" id="L151">              jks.setCertificateEntry(httpsAlias, cert);</span>
<span class="nc" id="L152">              jks.setKeyEntry(httpsAlias, key, keyStorePasswd.toCharArray(), certChain);</span>
            }
          }

        }

<span class="fc" id="L158">        keyManagerFactory.init(jks, keyStorePasswd.toCharArray());</span>

<span class="fc" id="L160">        SSLContext sslContext = sslConfig.createSSLContext().getInstance(tlsVersion);</span>
<span class="fc" id="L161">        sslContext.init(keyManagerFactory.getKeyManagers(), trustAllCerts, new SecureRandom());</span>

<span class="pc" id="L163">        return createClientBuilder().sslContext(sslContext).hostnameVerifier((hostname, session) -&gt; true).build();</span>
<span class="pc bpc" id="L164" title="6 of 8 branches missed.">      }</span>

<span class="nc" id="L166">    } catch (NoSuchAlgorithmException | KeyStoreException | IOException | CertificateException |</span>
        UnrecoverableKeyException | KeyManagementException e) {
<span class="nc" id="L168">      e.printStackTrace();</span>
<span class="nc" id="L169">      throw new RuntimeException(e);</span>
    }
  }

  public ClientBuilder createClientBuilder() {
<span class="fc" id="L174">    return ClientBuilder.newBuilder().register(MultiPartFeature.class)</span>
<span class="fc" id="L175">        .register(new GZIPReaderInterceptor()); //.register(new DecodingWriterInterceptor());</span>
  }

<span class="nc" id="L178">  public static class DecodingWriterInterceptor implements WriterInterceptor {</span>
    @Override
    public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException {

<span class="nc" id="L182">      LOGGER.debug(&quot;In the writer interceptor&quot;);</span>
<span class="nc" id="L183">    }</span>
  }

<span class="fc" id="L186">  public static class GZIPReaderInterceptor implements ReaderInterceptor {</span>

    @Override
    public Object aroundReadFrom(ReaderInterceptorContext context) throws IOException, WebApplicationException {

<span class="fc" id="L191">      MultivaluedMap&lt;String, String&gt; headers = context.getHeaders();</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">      if (headers.containsKey(HttpHeaders.CONTENT_ENCODING) &amp;&amp;</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">          headers.getFirst(HttpHeaders.CONTENT_ENCODING).equalsIgnoreCase(&quot;GZip&quot;)) {</span>
<span class="fc" id="L194">          LOGGER.debug(&quot;Content-Encoding is set to GZip in the response, unzipping first&quot;);</span>
<span class="fc" id="L195">          final InputStream originalInputStream = context.getInputStream();</span>
<span class="fc" id="L196">          context.setInputStream(new GZIPInputStream(originalInputStream));</span>
      }
<span class="fc" id="L198">      return context.proceed();</span>
    }
  }

  @SuppressWarnings(&quot;PMD.AvoidReassigningParameters&quot;)
  public URI buildUri(String baseUri, String pathTemplate, Map&lt;String, String&gt; queryParams, Object... pathParams) {

<span class="pc bpc" id="L205" title="2 of 4 branches missed.">    if (!baseUri.endsWith(&quot;/&quot;) &amp;&amp; !pathTemplate.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L206">      baseUri += &quot;/&quot;;</span>
    }
<span class="fc" id="L208">    UriBuilder builder = UriBuilder.fromUri(baseUri + pathTemplate);</span>

<span class="pc bpc" id="L210" title="2 of 4 branches missed.">    if (queryParams != null &amp;&amp; !queryParams.isEmpty()) {</span>
<span class="fc" id="L211">      queryParams.entrySet().stream().forEach(e -&gt; {</span>
<span class="fc" id="L212">        builder.queryParam(e.getKey(), e.getValue());</span>
<span class="fc" id="L213">      });</span>
    }

<span class="fc" id="L216">    return builder.build(pathParams, true);</span>
  }

  public void addHeader(String header, String value) {
<span class="fc" id="L220">    multivaluedMap.putSingle(header, value);</span>
<span class="fc" id="L221">  }</span>

  public void putIfAbsent(String header, List&lt;Object&gt; value) {
<span class="nc" id="L224">    multivaluedMap.putIfAbsent(header, value);</span>
<span class="nc" id="L225">  }</span>

  public void addHeaders(Map&lt;String, String&gt; headers) {
<span class="fc bfc" id="L228" title="All 2 branches covered.">    for (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) {</span>
<span class="fc" id="L229">      multivaluedMap.putSingle(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L230">    }</span>
<span class="fc" id="L231">  }</span>

  public void removeHeader(String header) {
<span class="fc" id="L234">    multivaluedMap.remove(header);</span>
<span class="fc" id="L235">  }</span>

  public void removeEtagRelatedHeaders() {
<span class="nc" id="L238">    multivaluedMap.remove(HttpHeaders.IF_MATCH);</span>
<span class="nc" id="L239">    multivaluedMap.remove(HttpHeaders.IF_NONE_MATCH);</span>
<span class="nc" id="L240">    multivaluedMap.remove(HttpHeaders.IF_MODIFIED_SINCE);</span>
<span class="nc" id="L241">  }</span>

  public void removeAuthHeader() {
<span class="nc" id="L244">    multivaluedMap.remove(HttpHeaders.AUTHORIZATION);</span>
<span class="nc" id="L245">  }</span>

  public void addAuthHeader(String assertion) {
<span class="nc" id="L248">    multivaluedMap.putSingle(HttpHeaders.AUTHORIZATION, &quot;SAML2 assertion=&quot; + assertion);</span>
<span class="nc" id="L249">  }</span>

  private void clearAllHeaders() {
<span class="nc bnc" id="L252" title="All 2 branches missed.">    if (multivaluedMap != null) {</span>
<span class="nc" id="L253">      multivaluedMap.clear();</span>
    }
<span class="nc" id="L255">  }</span>

  public Response getResponse() {
<span class="nc" id="L258">    checkNotNull(response);</span>
<span class="nc" id="L259">    return response;</span>
  }

  public boolean validateHttpResponseCode(int status) {
<span class="nc" id="L263">    checkNotNull(response);</span>
<span class="nc" id="L264">    assertEquals(status, response.getStatus());</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">    return status == response.getStatus();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>